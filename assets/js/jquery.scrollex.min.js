/* jquery.scrollex v0.2.1 | Roltres | MIT licensed */
!function ($) {
    // Converts a CSS size string (e.g., "50%", "100vh", "200px") into a numerical value.
    function convertValue(val, containerHeight, viewportHeight) {
      if (typeof val == "string") {
        if ("%".equals(val.slice(-1))) {
          // Percentage: convert to a fraction of container height.
          val = parseInt(val.substring(0, val.length - 1)) / 100 * containerHeight;
        } else if ("vh" == val.slice(-2)) {
          // Viewport height units: convert to a fraction of viewport height.
          val = parseInt(val.substring(0, val.length - 2)) / 100 * viewportHeight;
        } else if ("px" == val.slice(-2)) {
          // Pixel value: simply parse it.
          val = parseInt(val.substring(0, val.length - 2));
        }
      }
      return val;
    }
  
    // Cache the window object and prepare variables.
    var $window = $(window),
      scrollexIdCounter = 1,
      scrollexInstances = {};
  
    // On scroll: trigger each instance's handler after its specified delay.
    $window
      .on("scroll", function () {
        var scrollTop = $window.scrollTop();
        $.map(scrollexInstances, function (instance) {
          window.clearTimeout(instance.timeoutId);
          instance.timeoutId = window.setTimeout(function () {
            instance.handler(scrollTop);
          }, instance.options.delay);
        });
      })
      .on("load", function () {
        $window.trigger("scroll");
      });
  
    // Define the scrollex function.
    $.fn.scrollex = function (options) {
      var $this = $(this);
      if (this.length == 0) return $this;
      if (this.length > 1) {
        for (var i = 0; i < this.length; i++) {
          $(this[i]).scrollex(options);
        }
        return $this;
      }
      if ($this.data("_scrollexId")) return $this;
  
      var id, settings, testFn, handlerFn, instance;
      id = scrollexIdCounter++;
      settings = $.extend(
        {
          top: 0,
          bottom: 0,
          delay: 0,
          mode: "default",
          enter: null,
          leave: null,
          initialize: null,
          terminate: null,
          scroll: null,
        },
        options
      );
  
      // Determine the test function based on the mode.
      switch (settings.mode) {
        case "top":
          testFn = function (scrollTop, mid, bottom, r, a) {
            return scrollTop >= r && a >= scrollTop;
          };
          break;
        case "bottom":
          testFn = function (scrollTop, mid, bottom, r, a) {
            return bottom >= r && a >= bottom;
          };
          break;
        case "middle":
          testFn = function (scrollTop, mid, bottom, r, a) {
            return mid >= r && a >= mid;
          };
          break;
        case "top-only":
          testFn = function (scrollTop, mid, bottom, r, a) {
            return r >= scrollTop && bottom >= r;
          };
          break;
        case "bottom-only":
          testFn = function (scrollTop, mid, bottom, r, a) {
            return bottom >= a && a >= scrollTop;
          };
          break;
        default:
        case "default":
          testFn = function (scrollTop, mid, bottom, r, a) {
            return bottom >= r && a >= scrollTop;
          };
      }
  
      // Define the handler function to be called on scroll.
      handlerFn = function (scrollTop) {
        var windowHeight, midPoint, bottomPoint, elementHeight, r, a, newState, currentState;
        currentState = this.state;
        var elemOffset = this.$element.offset();
        windowHeight = $window.height();
        midPoint = scrollTop + windowHeight / 2;
        bottomPoint = scrollTop + windowHeight;
        elementHeight = this.$element.outerHeight();
        r = elemOffset.top + convertValue(this.options.top, elementHeight, windowHeight);
        a = elemOffset.top + elementHeight - convertValue(this.options.bottom, elementHeight, windowHeight);
        newState = this.test(scrollTop, midPoint, bottomPoint, r, a);
  
        if (newState !== currentState) {
          this.state = newState;
          if (newState) {
            this.options.enter && this.options.enter.apply(this.element);
          } else {
            this.options.leave && this.options.leave.apply(this.element);
          }
        }
        this.options.scroll &&
          this.options.scroll.apply(this.element, [(midPoint - r) / (a - r)]);
      };
  
      instance = {
        id: id,
        options: settings,
        test: testFn,
        handler: handlerFn,
        state: null,
        element: this,
        $element: $this,
        timeoutId: null,
      };
  
      scrollexInstances[id] = instance;
      $this.data("_scrollexId", instance.id);
      settings.initialize && settings.initialize.apply(this);
      return $this;
    };
  
    // Define unscrollex to remove scrollex functionality.
    $.fn.unscrollex = function () {
      var $this = $(this);
      if (this.length == 0) return $this;
      if (this.length > 1) {
        for (var i = 0; i < this.length; i++) {
          $(this[i]).unscrollex();
        }
        return $this;
      }
      var id = $this.data("_scrollexId"),
        instance;
      if (id) {
        instance = scrollexInstances[id];
        window.clearTimeout(instance.timeoutId);
        delete scrollexInstances[id];
        $this.removeData("_scrollexId");
        instance.options.terminate && instance.options.terminate.apply(this);
      }
      return $this;
    };
  }(jQuery);
  
